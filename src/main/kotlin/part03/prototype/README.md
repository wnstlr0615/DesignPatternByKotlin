## Prototype 패턴

---

클래스를 이름으로 생성하지 않고 clone 을 사용하여 복사를 통해 생성 방법

# 구현

**Product** : use, 와 createclone 메소드를 가지는 인터페이스

**Manager** : Product를 관리하고 createClone 메소드를 통해 인스턴스를 복제하는 클래스

**MessageBox** : Product를 구현하고 있는 클래스로 use와 createClone를 구현하고 있다.

**UnderlinePen** : Product를 구현하고 있는 클래스로 use와 createClone를 구현하고 있다.

**Main :**  manager에 Product 를 등록하고 꺼내서 사용하도록 구현되어 있다.

해당 코드에서 Manager안에 HashMap Product를 등록하고 createClone 메소드를 이용하여 꺼내 쓰는데 여기서 Manager 안에는 Prodcut를 구현 하고 있는 MessageBox나 UnderlienPen 클래스에 이름을 전혀 사용하지 않고있다. 소스 안에 클래스의 이름을 쓰면 그 클래스와 밀접한 관계가 생기는데 이로 써 관계를 끊어 줄 수 있다.

## Prototype 패턴을 사용하는 경우

1. **종류가 너무 많아 클래스로 정리가 되지 않는 경우**
    1. 취급 해야한 클래스가 너무 많아 각각을 별도의 클래스로 만들어 다수의 소스를 파일을 작성해야하는 경우
2. **클래스로부터 인스턴스 생성이 어려운 경우**
    1. 생성 하고 싶은 인스턴스가 복작한 작업을 거쳐 만들어지기 때문에 만들기가 매우 어려운 경우
    2. 사용자의 조작으로 만들어진 인스턴스를 다시 만들고 싶은 경우 지금 만든 인스턴스를 일단 저장해 두고 만들고 싶은 경우에 복사해서 사용
3. **framework와 생성할 인스턴스를 분리하고 싶은 경우**
    1. 인스턴스가 framework를 틀적 클래스에 의존하지 않도록 만들고 싶은 경우 이미 모형이 되는 인스턴스를 등록해 두고, 그 등록도니 인스턴스를 복사해서 인스턴스를 생성한다.

## 클래스 내부에서 다른 클래스 이름을 사용하면 안좋은 이유

클래스 내부에서 다른 클래스 이름을 사용하는 것이 항상 나쁘지는 않지만 소스 내부에서 다른 클래스 이름을 사용할 경우 그 클래스와 분리해서 지용할 수 없게된다. 클래스에 이름을 변경하여 수정하면 되지만 ‘**부품으로써 재이용** ‘ 이라는 기술하고는 다소 멀어지게된다.

긴밀하게 결합해야 한느 클래스 이름이 소스 안에서 사용되는 것은 문제가 없지만 부품으로써 독립시켜야하는 클래스 이름이 소스안에서 사용되는 것은 문제가 된다.

## Cloneable

Cloneable 인터페이스는 특정 클래스를 clone() 메소드를 통해 복사를 가능하도록 해주는 인터페이스로 따로 구현을 하지 않고 clone을 통해 복사가 된다는 것을 나타내주는 인터페이스이다.

Cloneable를 구현하지 않은 경우 **CloneNotSupportedException** 이 발생한다.